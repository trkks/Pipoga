using System;
using System.Collections.Generic;
using System.Linq;

using Microsoft.Xna.Framework;

using Pipoga;

namespace Pipoga
{
    public class Circle : IRasterizable
    {
        public float radius;
        public Vector2 center;
        
        public Circle(float radius, Vector2 center)
        {
            this.radius = radius;
            this.center = center;
        }

        /// <summary>
        /// Algorithm from:
        /// https://en.wikipedia.org/wiki/Midpoint_circle_algorithm#Variant_with_integer-based_arithmetic
        /// </summary>
        public IEnumerable<Vertex> GetVertices(Vector2 inversePixelSize)
        {
            // TODO Scaling only based on X-component does not work with
            // non-square pixels.
            int pixelRadius = (int)(inversePixelSize.X * radius);
            Point translation = (center * inversePixelSize).ToPoint();

            // Generate one octant (1/8) of the circle.
            // Move counter-clockwise starting from the
            // coordinate (radius, 0).
            var origOctant = new List<Point>(0xff);
            (int xi, int yi) = (pixelRadius, 0);
            // Precompute square radius.
            int rr = pixelRadius * pixelRadius;
            while (xi >= yi)
            {
                origOctant.Add(new Point(xi, yi));

                yi++;
                int a = 2
                    * ((xi * xi + yi * yi - rr) + (2 * yi + 1))
                    + (1 - 2 * xi);
                if (a > 0)
                {
                    xi--;
                }
            }

            // The other 7 octants are generated by reflecting and rotating the
            // original.
            Func<Point, Point, Point> reflect = (v, l) =>
                new Point(2)
                * new Point((v.X * l.X + v.Y * l.Y) / (l.X * l.X + l.Y * l.Y))
                * l
                - v;

            foreach (var (octant, color)
                in new[]
                {
                    (origOctant,
                        Color.Red),
                    (origOctant.Select(p => reflect(p, new Point(0, 1))),
                        Color.Green),
                    (origOctant.Select(p => reflect(p, new Point(1, 0))),
                        Color.Blue),
                    (origOctant.Select(p => reflect(reflect(p, new Point(0, 1)), new Point(1, 0))),
                        Color.Purple)
                }
            )
            {
                foreach (var point in octant)
                {
                    yield return new Vertex(
                        point.X + translation.X,
                        point.Y + translation.Y,
                        color);
                    // Return 90-degree-rotated as well.
                    yield return new Vertex(
                        -point.Y + translation.X,
                        point.X + translation.Y,
                        Color.Lerp(color, Color.Black, 0.5f));
                }
            }
        }
    }
}
